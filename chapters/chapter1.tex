% Free range VHDL
% Authors: Bryan Mealy, Fabrizio Tappero
% Date: January, 2023
% URL: https://github.com/fabriziotappero/Free-Range-VHDL-book
% (C) 2018-2023 B. Mealy, F. Tappero
%
% !TEX root = master.tex
%
\chapter{Introduction To VHDL}
VHDL has a rich and interesting history\footnote{VHDL-Wikipedia: {\footnotesize\url{http://en.wikipedia.org/wiki/VHDL}}}. But since knowing this history is probably not going to help you write better VHDL code, it will only be briefly mentioned here. Consulting other, lengthier texts or search engines will provide more information for those who are interested. Regarding the VHDL acronym,  the V is short for yet another acronym: VHSIC or Very High-Speed Integrated Circuit. The HDL stands for Hardware Description Language. Clearly, the state of technical affairs these days has done away with the need for nested acronyms. VHDL is a true computer language with the accompanying set of syntax and usage rules. But, as opposed to higher-level computer languages, VHDL is primarily used  to \textit{describe hardware}. The tendency for most people familiar with a higher-level computer language such as C or Java is to view VHDL as just another computer language. This is not altogether a bad approach if such a view facilitates the understanding and memorization of the language syntax and structure. The common mistake made by someone with this approach is to attempt to program in VHDL as they would program a higher-level computer language. Higher-level computer languages are sequential in nature; VHDL is not.

VHDL was invented to describe hardware and in fact VHDL is a \textit{concurrent} language. What this means is that, normally, VHDL instructions are all executed at the same time (concurrently), regardless of the size of your implementation. Another way of looking at this is that higher-level computer languages are used to describe algorithms (sequential execution) and VHDL is used to describe hardware (parallel execution). This inherent difference should necessarily encourage you to re-think how you write your VHDL code. Attempts to write VHDL code with a high-level language style generally result in code that nobody understands. Moreover, the tools used to synthesize\footnote{Synthesis: the process of interpreting VHDL code and outputting a definition of the physical circuit implementation to be programmed on a device such as an FPGA.} this type of code has a tendency to generate circuits that generally do not work correctly and have bugs that are nearly impossible to trace. And if the circuit does actually work, it will most likely be inefficient due to the fact that the resulting hardware was unnecessarily large and overly complex. This problem is compounded as the size and complexity of your circuits becomes greater.

There are two primary purposes for hardware description languages such as VHDL. First, VHDL can be used to model digital circuits and systems. Although the word ``model'' is one of those overly used words in engineering, in this context it simply refers to a description of something that presents a certain level of detail. The nice thing about VHDL is that the level of detail is unambiguous due to the rich syntax rules associated with it. In other words, VHDL provides everything that is necessary in order to describe any digital circuit. Likewise, a digital circuit/system is any circuit that processes or stores digital information. Second, having some type of circuit model allows for the subsequent simulation and/or testing of the circuit. The VHDL model can also be translated into a form that can be used to generate actual working circuits. The VHDL model is magically\footnote{It is not really magic. There is actually a well-defined science behind it.} interpreted by software tools in such a way as to create actual digital circuits in a process known as \textit{synthesis}.

There are other logic languages available to model the behavior of digital circuit designs that are easy to use because they provide a graphical method to model circuits. For them, the tendency is to prefer the graphical approach because it has such a comfortable learning curve. But, as you can easily imagine, your growing knowledge of digital concepts is accompanied by the ever-increasing complexity of digital circuits you are dealing with. The act of graphically connecting a bunch of lines on the computer screen quickly becomes tedious. The more intelligent approach to digital circuit design is to start with a system that is able to describe exactly how your digital circuit works (in other words, modeling it) without having to worry about the details of connecting large quantities of signal lines. Having a working knowledge of VHDL will provide you with the tools to model digital circuits in a much more intelligent manner.

Finally, you will be able to use your VHDL code to create actual functioning circuits. This allows you to implement relatively complex circuits in a relatively short period of time. The design methodology you will be using allows you to dedicate more time to designing your circuits and less time ``constructing'' them. The days of placing, wiring and troubleshooting multiple integrated circuits on a proto-board are gone.

VHDL is a very exciting language that can allow the design and implementation of functions capable of processing an enormous amount of data by employing a relatively low-cost and low-power hardware. Moreover, what is really impressive is that, via simple VHDL modules, you can have direct access to basic ns-level logic events as well as communicate using a USB port or drive a VGA monitor to visualize graphics of modest complexity.

Modeling digital circuits with VHDL is a form of modern digital design distinct from schematic-based approaches. The programmer writes a loose description of what the final logic circuit should do and a language compiler, in this case called a synthesizer, attempts to ``infer'' what the actual final physical logic circuit should be. Novice programmers are not always able to convince the synthesizer to implement something that seems very clear in their minds.
A somehow old-fashioned alternative to a descriptive language such as VHDL is one in which the programmer simply interconnects a finite number of digital blocks that he has pooled from a library in an attempt to reach the same objective. This approach is not only very time consuming but also inherently limiting and very error prone.

Modern digital design is more about appropriately modeling digital circuits and maintaining a quality description of the circuit. All that is left now is to learn how to properly use VHDL to describe what you want to implement.

\section{Golden Rules of VHDL}
Before you start, here are a couple of points that you should never forget when working with VHDL.\\

\noindent
\textbf{VHDL is a hardware-design language.} Although most people have probably already been exposed to some type of higher-level computer language, these skills are only indirectly applicable to VHDL. When you are working with VHDL, you are not programming, you are ``designing hardware''. Your VHDL code should reflect this fact. What does this mean? It means that unless you are inside certain constructs, your code lines will be executed almost all at once. If your VHDL code appears too similar to code of a higher-level computer language, it is probably bad VHDL code. This is vitally important.\\

\noindent
\textbf{Have a general concept of what your hardware should look like.} Although VHDL is vastly powerful, if you do not understand basic digital constructs, you will probably be unable to generate efficient digital circuits. Digital design is similar to higher-level language programming in that even the most complicated programming at any level can be broken down into some simple programming constructs. There is a strong analogy to digital design in that even the most complicated digital circuits can be described in terms of basic digital constructs. In other words, if you are not able to roughly envision the digital circuit you are trying to model in terms of basic digital circuits, you will probably misuse VHDL, thus angering the VHDL gods. VHDL is cool, but it is not as magical as it initially appears to be.

\section{Tools Needed for VHDL Development}
VHDL is a language used to implement hardware which will run other software (for example C). A Field Programmable Gate Array (FPGA) is probably the most common device that you can use for your VHDL implementations. If you want to do VHDL coding for FPGAs you will have to play within the rules that current major FPGA manufacturers have drawn up to help you (rules which also ensure their continued existence in the market).

The successful implementation of a VHDL-based system roughly calls for the following steps: VHDL code writing, compiling, simulation and synthesis. All major FPGA manufacturers have a set of software and hardware tools that you can use to perform the mentioned steps. Most of these software tools are free of charge but are not open-source. Nevertheless, the same tools follow a license scheme, whereby paying a certain amount of money allows you to take advantage of sophisticated software features or get your hands on proprietary libraries with lots of components (e.g. a 32-bit processor) that you can easily include in your own project.

If you have no interest in proprietary libraries, you can use open-source solutions (e.g. GHDL\footnote{VHDL simulator GHDL: {\footnotesize\url{http://ghdl.free.fr}}} or BOOT\footnote{VHDL software tool BOOT: {\footnotesize\url{https://github.com/fabriziotappero/Free-Range-VHDL-book}}}) which will allow you to compile and simulate your VHDL code using the open-source tool \textit{gcc\footnote{Multi-language open-source compiler GCC: {\footnotesize\url{http://gcc.gnu.org}}}}. At the time of writing, no open-source solution is available for the synthesis process. However synthesis can be accomplished using a free-license version of any major FPGA manufacturer's software tool (e.g. Xilinx Vivado).

Thanks to the open-source community, you can write, compile and simulate VHDL systems using excellent open-source solutions. This book will show you how to get up and running with the VHDL language. For further tasks such as synthesis and upload of your code into an FPGA, the free of charge Xilinx Vivado\footnote{Xilinx Vivado: {\scriptsize\url{https://www.xilinx.com/products/design-tools/vivado.html}}} or the Altera equivalent tool Quartus, can be employed.
